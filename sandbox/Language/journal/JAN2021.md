# 01 JAN 2021 Lexical Scoping

We left last year trying to think of how to handle situations like this:

```brief
let 'fry [flatmap [if [fry.fill] [fry.deepfry] fry.hole?]]
    let 'fry.fill [unless [quote] list? dup rot drop]
    let 'fry.deepfry [if [quote rot 2dip [fry] -rot] [quote] list? dup]
    let 'fry.hole? [= >sym '_ dup]
```

A word defined in terms of "child" words that aren't meant to be generally useful. This idea of prefixing with `fry.` isn't satisfactory.

An interesting thing to notice is that `let` expressions can actually be used _within_ word definitions. In fact, an interesting idea is to use "dangling `lets`" to name values from the stack:

```brief
let 'pyth [sqrt + * a a * b b let 'b let 'a]
```

That's a nice, direct mapping from the mathematical expression. Perhaps not as simple as `let 'pyth [sqrt + sq swap sq]` in this case, but the idea that values may be named this way is interesting. We could potentially redefine some of the stack shuffling words this way:

```brief
let 'drop [let '_]
let 'dup [x x let 'x]
let 'swap [y x let 'y let 'x]
let 'over [y x y let 'y let 'x]
let 'pick [z x y z let 'z let 'y let 'x]
```

There are some issues with this around how `let` and application of definitions handle `Lists` vs. other kinds of values. We could `quote` the values to turn `Lists` into definitions that push a `List` literal, but then run into problems with `quote` being defined in terms of `swap`, recursively.

Anyway, we're getting totally side tracked. the real purpose of this feature is to make definitions like this:

```brief
let 'fry [flatmap [if [fill] [deepfry] hole?]
    let 'fill [unless [quote] list? dup rot drop]
    let 'deepfry [if [quote rot 2dip [fry] -rot] [quote] list? dup]
    let 'hole? [= >sym '_ dup]]
```

The three "inner `lets`" are defined and used by the `fry` word exclusively. The remaining problem is that `let`, whether "inner" or not, defines things in a global dictionary. Let's chage the `Dictionary` to a _`List`_ of `Maps`:

```fsharp
and State = {
    Dictionary: Map<string, Value> List
    ... }
```

We'll search this "chain" of dictionary "frames" from head to tail:

```fsharp
let tryFindWord n dict =
    let rec tryFind = function
        | h :: t ->
            match Map.tryFind n h with
            | Some v -> Some v
            | None -> tryFind t
        | [] -> None
    tryFind dict
```

Adding a few more helpers to add and drop words and frames:

```fsharp
let addFrame dict = Map.empty :: dict

let dropFrame = function
    | _ :: [] -> failwith "Cannot drop final dictionary frame"
    | _ :: t -> t
    | [] -> failwith "Malformed dictionary"

let addWord n v = function
    | h :: t -> (Map.add n v h) :: t
    | [] -> failwith "Malformed dictionary"
```

These will be used throughout. Most importantly, the interpreter will now change to add a dictionary frame each time a secondary word is evaluated. Any "inner" `let` will add to _this_ frame. With a tricky bit of mechanics, a `_return` word is then added after the expanded continuation so that, once complete, the new dictionary frame will be dropped. This way, inner `lets` are available only within the parent (or anscestors in general) and don't polute the global dictionary. Also, they may shaddow global words temporarily.

```fsharp
primitive "_return" (fun s -> { s with Dictionary = dropFrame s.Dictionary })

let rec interpret state stream =
    let word state w = 
        match w with
        | Symbol s ->
            match tryFindWord s state.Dictionary with
            | Some (List l) ->
                { state with Dictionary = addFrame state.Dictionary
                             Continuation = List.rev l @ Symbol "_return" :: state.Continuation }
            | Some v -> ...
            | None -> ...
        | v -> ...
    ...
```

Very simple.

In the future, we may want to pre-compile definitions and attach an "environment" to each containing the head dictionary frame. Also, symbols may be resolved at compile-time. This will likely require a bottom-up ordering of definitions and some way of handling mutual recursion.

# 02 JAN 2020 Testing

Before working on some planned refactoring, let's add some facility to add tests.

```brief
let 'assertTrue [clear print fry [_ " " _ "\n"] if ['PASS] ['FAIL] apply swap]
let 'assertFalse [assertTrue dip [compose [not]]]
let 'assertEqual [assertTrue dip [quote =] 2dip [apply]]

let 'test [load 'Tests]
```

This allows us to populate a `Tests.b` file with unit tests:

```brief
assertEqual "Addition" 7 [+ 4 3]
assertEqual "Subtraction" -1 [- 4 3]
assertEqual "Multiplication" 12 [* 4 3]
assertEqual "Division" 0.5 [/ 4 2]

assertEqual "Reverse" [3 2 1] [reverse [1 2 3]]
assertEqual "Fry" [1 foo [2 bar [baz]]] [fry [_ foo [_ bar _]] 1 2 [[baz]]]

assertEqual "Depth" 3 [depth 1 2 3]
assertEqual "Clear" 0 [depth clear 1 2 3]

assertEqual "Drop" 0 [depth drop 'foo]
assertEqual "Swap" [2 1] [cons dip [cons] swap 1 2 []]
```

# 03 JAN 2020 Exposing Internals

The tests above led to the thinking that the internals could be simplified and exposed directly. For example, the `"Swap"` test:

```brief
assertEqual "Swap" [2 1] [cons dip [cons] swap 1 2 []]
```

It's a bit unwieldy to have to `cons` together a list containing the stack for the test. If we had a means to look at the stack as a value, it could be simplified. Going all the way back to debate #8, this had been an idea on the back burner. Let's remove the `Stack` and add it as a simple value in the `Map`:

```fsharp
let _stack = "_stack"

let emptyState = {
    Continuation = []
    Map = Map.ofList [_stack, List []]
    Dictionary = [Map.empty]
    Primitives = Map.empty }

let getStack state = match Map.tryFind _stack state.Map with Some (List s) -> s | _ -> failwith "Malformed stack"
let setStack state (stack: Value list) = { state with Map = Map.add _stack (List stack) state.Map }
```

That's easy enough to change throughout and now the tests can be rewritten as:

```brief
assertEqual "Swap" [2 1] [@map '_stack swap 1 2]
assertEqual "Dip" [1 6] [@map '_stack dip [*] 1 2 3]
...
```

Additionally, a couple of primitives can now become secondaries:

```brief
let 'clear [!map '_stack []]
let 'depth [nip count @map '_stack]
```

Let's go further and move _everything_ into the `Map`! In fact, the `State` would then _only_ contain the `Map`. Instead, let's define as merely a map (`State = Map<string, Value>`).

```fsharp
let _stack        = "_stack"
let _continuation = "_continuation"
let _dictionary   = "_dictionary"

let emptyState = Map.ofList [
    _stack, List []
    _continuation, List []
    _dictionary, List [Map Map.empty]]
```

To move the `Primitives` to the dictionary, let's promote them to proper `Values` and also bring back our `IComparable` `Primitive` type:

```fsharp
type Value =                        // v
    | Word    of Primitive          // w
    ...
```

The interpreter now handles `Words` by simply applying them to the state (`w.Func state`):

```fsharp
...
match tryFindWord s (getDictionary state) with
| Some (List l) -> ... // expand as continuation
| Some (Word w) -> w.Func state
| Some v -> ... // push to stack
| None -> failwith (sprintf "Unknown word '%s'" s)
```

# 09 JAN 2021 Booleans

Just a small simplification of sorts: Getting rid of the `Boolean` type and replacing with a convention of `-1` meaning `true` and `0` meaning `false`. This unifies boolean and bitwise operations and removes a type from the system, and with slightly more flexible semantics.

```brief
let 'true -1
let 'false 0
```

The `if` word is relaxed to consider _any_ non-zero `Number` to mean `true`. This allows for expressions such as `when [...] count ...` to switch directly on whether the `count` is zero rather than requiring `<> 0 count` or `not empty?`:

```fsharp
 primitive "if" (fun s ->
    match getStack s with
    | List q :: List r :: Number b :: t ->
        (List.rev (if b <> 0.0 then q else r)) @ getContinuation s |> setContinuation (setStack s t)
    ...
```

Boolean operations `and` and `or` change to work with `Numbers`. Interestingly, they become _bitwise_ operations because `-1` is all bits on. This unified the boolean and bitwise operations. Funny that languages like F# have `&&`, `||`, `not` vs. `&&&`, `|||`, `~~~` and languages like C have `&&`, `||`, `!` vs. `&`, `|`, `~`.

```fsharp
let booleanOp name op = primitive name (fun s ->
    match getStack s with
    | Number x :: Number y :: t -> Number (op (int x) (int y) |> double) :: t |> setStack s^M
    ...

booleanOp "and" (&&&)^M
booleanOp "or" (|||)^M

primitive "not" (fun s ->
    match getStack s with
    | Number x :: t -> (Number (~~~(int x) |> double)) :: t |> setStack s^M
    ...
```

Notice that, as boolean operations, these may do the wrong thing if the value is not a "well formed" `-1` or `0`. There is no check for this so that it may equally be used as a bitwise operation; making the language more "dynamic."

Finally, the comparison operations now produce a proper `-1`/`0` value:

```fsharp
 let comparisonOp name op = primitive name (fun s ->
     match getStack s with
     | x :: y :: t -> Number (if (op y x) then -1. else 0.) :: t |> setStack s^M
     ...

comparisonOp "=" (=)
comparisonOp ">" (>)
```

The `>bool` word goes away, and pretty printing no longer shows `true`/`false`; though words for these constants are added for code clarity.

# 10 JAN 2021 Debugging

While changing the semantics of booleans yesterday, a difficult to debug infinite recursion was accidentally caused! In general, we've been avoiding adding features until they're needed. We need a debugger!

Let's change the interpreter to walk step-by-step through the code:

```fsharp
let step state =
    match getContinuation state with
    | Symbol "_return" :: c -> updateDictionary dropFrame state |> setContinuation c
    | Symbol s :: c -> 
        match tryFindWord s state with
        | Some (List l) -> addFrame state |> setContinuation (List.rev l @ Symbol "_return" :: c)
        | Some (Word w) -> setContinuation c state |> w.Func
        | Some v -> pushStack v state |> setContinuation c
        | None -> failwith (sprintf "Unknown word '%s'" s)
    | v :: c -> pushStack v state |> setContinuation c
    | [] -> state

let interpret state code =
    let rec interpret' state =
        match getContinuation state with
        | [] -> state
        | Symbol "_break" :: c -> setContinuation c state
        | _ -> step state |> interpret'
    updateContinuation (fun c -> List.ofSeq code @ c) state |> interpret'
```

This removes the feature in which a "stream" (`Value seq`) of code would be interpreted _as_ words and values came in. Instead, now we immediately reify the sequence (`List.ofSeq`) and place all of the code on the continuation up front. This is much simpler for debugging and we may revisit streaming later.

This also removes the `_return` primitive and instead it is a "special" internal word, both added and understood in the `step` function.

The interpreter now `steps` until the continuation is empty _or_ it hits a `_break` word. This means we can now set "break points" with this word! Pressing ENTER at the REPL will continue interpreting after breaking.
