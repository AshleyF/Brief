# DEC 2020

* [Lexical Scoping](https://github.com/AshleyF/brief/blob/gh-pages/sandbox/Language/journal/JAN2021.md#02-jan-2021-lexical-scoping)

# 02 JAN 2021 Lexical Scoping

We left last year trying to think of how to handle situations like this:

```brief
let 'fry [flatmap [if [fry.fill] [fry.deepfry] fry.hole?]]
    let 'fry.fill [unless [quote] list? dup rot drop]
    let 'fry.deepfry [if [quote rot 2dip [fry] -rot] [quote] list? dup]
    let 'fry.hole? [= >sym '_ dup]
```

A word defined in terms of "child" words that aren't meant to be generally useful. This idea of prefixing with `fry.` isn't satisfactory.

An interesting thing to notice is that `let` expressions can actually be used _within_ word definitions. In fact, an interesting idea is to use "dangling `lets`" to name values from the stack:

```brief
let 'pyth [sqrt + * a a * b b let 'b let 'a]
```

That's a nice, direct mapping from the mathematical expression. Perhaps not as simple as `let 'pyth [sqrt + sq swap sq]` in this case, but the idea that values may be named this way is interesting. We could potentially redefine some of the stack shuffling words this way:

```brief
let 'drop [let '_]
let 'dup [x x let 'x]
let 'swap [y x let 'y let 'x]
let 'over [y x y let 'y let 'x]
let 'pick [z x y z let 'z let 'y let 'x]
```

There are some issues with this around how `let` and application of definitions handle `Lists` vs. other kinds of values. We could `quote` the values to turn `Lists` into definitions that push a `List` literal, but then run into problems with `quote` being defined in terms of `swap`, recursively.

Anyway, we're getting totally side tracked. the real purpose of this feature is to make definitions like this:

```brief
let 'fry [flatmap [if [fill] [deepfry] hole?]
    let 'fill [unless [quote] list? dup rot drop]
    let 'deepfry [if [quote rot 2dip [fry] -rot] [quote] list? dup]
    let 'hole? [= >sym '_ dup]]
```

The three "inner `lets`" are defined and used by the `fry` word exclusively. The remaining problem is that `let`, whether "inner" or not, defines things in a global dictionary. Let's chage the `Dictionary` to a _`List`_ of `Maps`:

```fsharp
and State = {
    Dictionary: Map<string, Value> List
    ... }
```

We'll search this "chain" of dictionary "frames" from head to tail:

```fsharp
let tryFindWord n dict =
    let rec tryFind = function
        | h :: t ->
            match Map.tryFind n h with
            | Some v -> Some v
            | None -> tryFind t
        | [] -> None
    tryFind dict
```

Adding a few more helpers to add and drop words and frames:

```fsharp
let addFrame dict = Map.empty :: dict

let dropFrame = function
    | _ :: [] -> failwith "Cannot drop final dictionary frame"
    | _ :: t -> t
    | [] -> failwith "Malformed dictionary"

let addWord n v = function
    | h :: t -> (Map.add n v h) :: t
    | [] -> failwith "Malformed dictionary"
```

These will be used throughout. Most importantly, the interpreter will now change to add a dictionary frame each time a secondary word is evaluated. Any "inner" `let` will add to _this_ frame. With a tricky bit of mechanics, a `_dropFrame` word is then added after the expanded continuation so that, once complete, the new dictionary frame will be dropped. This way, inner `lets` are available only within the parent (or anscestors in general) and don't polute the global dictionary. Also, they may shaddow global words temporarily.

```fsharp
primitive "_dropFrame" (fun s -> { s with Dictionary = dropFrame s.Dictionary })

let rec interpret state stream =
    let word state w = 
        match w with
        | Symbol s ->
            match tryFindWord s state.Dictionary with
            | Some (List l) ->
                { state with Dictionary = addFrame state.Dictionary
                             Continuation = List.rev l @ Symbol "_dropFrame" :: state.Continuation }
            | Some v -> { state with Dictionary = addFrame state.Dictionary
                                     Continuation = v :: Symbol "_dropFrame" :: state.Continuation }
            | None -> ...
        | v -> ...
    ...
```

Very simple.

In the future, we may want to pre-compile definitions and attach an "environment" to each containing the head dictionary frame. Also, symbols may be resolved ad compile-time. This will likely require a bottom-up ordering of definitions.
