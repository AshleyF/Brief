assertEqual "lex brackets" ['test '\] '\} 'a '\{ 'is '\[ 'this] [lex "this [is {a}] test"]
assertEqual "lex regular strings" ['test "'foo is a" 'this] [lex "this \"foo is a\" test"]
assertEqual "lex tick strings" ['baz ''bar 'foo] [lex "foo 'bar baz"]
assertEqual "lex escaped chars" ["'\b \f \n \r \t \\ x"] [lex "\"\b \f \n \r \t \\ \x\""]

assertEqual "parse list" [this ['is 123 a] test] [parse lex "this ['is 123 a] test"]

let 'whitespace? [any? swap [" " '\r '\n '\t] fry [= _] dup]

let 'lex [tokenize rot [] [] split
    let 'tokenize [cond [[done]                     [empty?]
                         [tokenize token drop]      [whitespace? snoc]
                         [tokenize singleCharToken] [brackets?]
                         [tick addChar]             [firstCharIs? '']
                         [str addChar '' drop]      [firstCharIs? '"]
                         [tokenize addChar]]
        let 'firstCharIs? [apply fry [and dip [= _ dup] rot 2dip [empty?]]]]
    let 'str [cond [[tokenize token drop]  [= '" dup snoc]
                    [str addChar unescape] [= '\\ dup]
                    [str addChar]]]
    let 'tick [cond [[done]                     [empty?]
                     [tokenize token drop]      [whitespace? snoc]
                     [tokenize singleCharToken] [brackets?]
                     [tick addChar unescape]    [= '\\ dup]
                     [tick addChar]]]
    let 'unescape [cond [['\b drop] [= 'b dup]
                         ['\f drop] [= 'f dup]
                         ['\n drop] [= 'n dup]
                         ['\r drop] [= 'r dup]
                         ['\t drop] [= 't dup]]]
    let 'done [2drop token]
    let 'addChar [dip [cons] swap]
    let 'emptyToken? [swap dip [empty?]]
    let 'brackets? [any? swap ["[" "]" "{" "}" ] fry [= _] dup]
    let 'singleCharToken [token dip [cons] swap dip [token]]
    let 'token [swap [] if [drop] [dip [cons] swap join reverse] empty? swap]]

let 'parse [next swap []
    let 'next [cond [[drop]                       [empty?]
                     [next dip [cons] parse drop] [= '\] dup snoc]
                     [drop]                       [or bi [= '\{] [= '\[] dup]
                     [next buildMap parse drop]   [= '\} dup]
                     [next dip [cons convert] swap]]]]
    let 'convert [cond [[join tail split] [= '' head split dup]
                        [nip]             [>num? dup]
                        [>sym]]]
    let 'buildMap [build rot { }]
        let 'build [if [dip [cons] swap drop]
                       [build dip [! swap] swap snoc swap snoc] empty?]
